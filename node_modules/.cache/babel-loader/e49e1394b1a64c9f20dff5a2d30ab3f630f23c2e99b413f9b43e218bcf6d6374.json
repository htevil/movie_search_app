{"ast":null,"code":"// src/internal/tabbable.ts\nvar computedStyleMap = /* @__PURE__ */new WeakMap();\nfunction getCachedComputedStyle(el) {\n  let computedStyle = computedStyleMap.get(el);\n  if (!computedStyle) {\n    computedStyle = window.getComputedStyle(el, null);\n    computedStyleMap.set(el, computedStyle);\n  }\n  return computedStyle;\n}\nfunction isVisible(el) {\n  if (typeof el.checkVisibility === \"function\") {\n    return el.checkVisibility({\n      checkOpacity: false,\n      checkVisibilityCSS: true\n    });\n  }\n  const computedStyle = getCachedComputedStyle(el);\n  return computedStyle.visibility !== \"hidden\" && computedStyle.display !== \"none\";\n}\nfunction isOverflowingAndTabbable(el) {\n  const computedStyle = getCachedComputedStyle(el);\n  const {\n    overflowY,\n    overflowX\n  } = computedStyle;\n  if (overflowY === \"scroll\" || overflowX === \"scroll\") {\n    return true;\n  }\n  if (overflowY !== \"auto\" || overflowX !== \"auto\") {\n    return false;\n  }\n  const isOverflowingY = el.scrollHeight > el.clientHeight;\n  if (isOverflowingY && overflowY === \"auto\") {\n    return true;\n  }\n  const isOverflowingX = el.scrollWidth > el.clientWidth;\n  if (isOverflowingX && overflowX === \"auto\") {\n    return true;\n  }\n  return false;\n}\nfunction isTabbable(el) {\n  const tag = el.tagName.toLowerCase();\n  const tabindex = Number(el.getAttribute(\"tabindex\"));\n  const hasTabindex = el.hasAttribute(\"tabindex\");\n  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {\n    return false;\n  }\n  if (el.hasAttribute(\"disabled\")) {\n    return false;\n  }\n  if (el.closest(\"[inert]\")) {\n    return false;\n  }\n  if (tag === \"input\" && el.getAttribute(\"type\") === \"radio\" && !el.hasAttribute(\"checked\")) {\n    return false;\n  }\n  if (!isVisible(el)) {\n    return false;\n  }\n  if ((tag === \"audio\" || tag === \"video\") && el.hasAttribute(\"controls\")) {\n    return true;\n  }\n  if (el.hasAttribute(\"tabindex\")) {\n    return true;\n  }\n  if (el.hasAttribute(\"contenteditable\") && el.getAttribute(\"contenteditable\") !== \"false\") {\n    return true;\n  }\n  const isNativelyTabbable = [\"button\", \"input\", \"select\", \"textarea\", \"a\", \"audio\", \"video\", \"summary\", \"iframe\"].includes(tag);\n  if (isNativelyTabbable) {\n    return true;\n  }\n  return isOverflowingAndTabbable(el);\n}\nfunction getTabbableBoundary(root) {\n  var _a, _b;\n  const tabbableElements = getTabbableElements(root);\n  const start = (_a = tabbableElements[0]) != null ? _a : null;\n  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;\n  return {\n    start,\n    end\n  };\n}\nfunction getSlottedChildrenOutsideRootElement(slotElement, root) {\n  var _a;\n  return ((_a = slotElement.getRootNode({\n    composed: true\n  })) == null ? void 0 : _a.host) !== root;\n}\nfunction getTabbableElements(root) {\n  const walkedEls = /* @__PURE__ */new WeakMap();\n  const tabbableElements = [];\n  function walk(el) {\n    if (el instanceof Element) {\n      if (el.hasAttribute(\"inert\") || el.closest(\"[inert]\")) {\n        return;\n      }\n      if (walkedEls.has(el)) {\n        return;\n      }\n      walkedEls.set(el, true);\n      if (!tabbableElements.includes(el) && isTabbable(el)) {\n        tabbableElements.push(el);\n      }\n      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {\n        el.assignedElements({\n          flatten: true\n        }).forEach(assignedEl => {\n          walk(assignedEl);\n        });\n      }\n      if (el.shadowRoot !== null && el.shadowRoot.mode === \"open\") {\n        walk(el.shadowRoot);\n      }\n    }\n    for (const e of el.children) {\n      walk(e);\n    }\n  }\n  walk(root);\n  return tabbableElements.sort((a, b) => {\n    const aTabindex = Number(a.getAttribute(\"tabindex\")) || 0;\n    const bTabindex = Number(b.getAttribute(\"tabindex\")) || 0;\n    return bTabindex - aTabindex;\n  });\n}\nexport { getTabbableBoundary, getTabbableElements };","map":{"version":3,"names":["computedStyleMap","WeakMap","getCachedComputedStyle","el","computedStyle","get","window","getComputedStyle","set","isVisible","checkVisibility","checkOpacity","checkVisibilityCSS","visibility","display","isOverflowingAndTabbable","overflowY","overflowX","isOverflowingY","scrollHeight","clientHeight","isOverflowingX","scrollWidth","clientWidth","isTabbable","tag","tagName","toLowerCase","tabindex","Number","getAttribute","hasTabindex","hasAttribute","isNaN","closest","isNativelyTabbable","includes","getTabbableBoundary","root","_a","_b","tabbableElements","getTabbableElements","start","end","length","getSlottedChildrenOutsideRootElement","slotElement","getRootNode","composed","host","walkedEls","walk","Element","has","push","HTMLSlotElement","assignedElements","flatten","forEach","assignedEl","shadowRoot","mode","e","children","sort","a","b","aTabindex","bTabindex"],"sources":["C:/Users/ASUS/Project/Web Project/Greekforgreek_project/React project/movie_search_app/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXDTFLWU.js"],"sourcesContent":["// src/internal/tabbable.ts\nvar computedStyleMap = /* @__PURE__ */ new WeakMap();\nfunction getCachedComputedStyle(el) {\n  let computedStyle = computedStyleMap.get(el);\n  if (!computedStyle) {\n    computedStyle = window.getComputedStyle(el, null);\n    computedStyleMap.set(el, computedStyle);\n  }\n  return computedStyle;\n}\nfunction isVisible(el) {\n  if (typeof el.checkVisibility === \"function\") {\n    return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });\n  }\n  const computedStyle = getCachedComputedStyle(el);\n  return computedStyle.visibility !== \"hidden\" && computedStyle.display !== \"none\";\n}\nfunction isOverflowingAndTabbable(el) {\n  const computedStyle = getCachedComputedStyle(el);\n  const { overflowY, overflowX } = computedStyle;\n  if (overflowY === \"scroll\" || overflowX === \"scroll\") {\n    return true;\n  }\n  if (overflowY !== \"auto\" || overflowX !== \"auto\") {\n    return false;\n  }\n  const isOverflowingY = el.scrollHeight > el.clientHeight;\n  if (isOverflowingY && overflowY === \"auto\") {\n    return true;\n  }\n  const isOverflowingX = el.scrollWidth > el.clientWidth;\n  if (isOverflowingX && overflowX === \"auto\") {\n    return true;\n  }\n  return false;\n}\nfunction isTabbable(el) {\n  const tag = el.tagName.toLowerCase();\n  const tabindex = Number(el.getAttribute(\"tabindex\"));\n  const hasTabindex = el.hasAttribute(\"tabindex\");\n  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {\n    return false;\n  }\n  if (el.hasAttribute(\"disabled\")) {\n    return false;\n  }\n  if (el.closest(\"[inert]\")) {\n    return false;\n  }\n  if (tag === \"input\" && el.getAttribute(\"type\") === \"radio\" && !el.hasAttribute(\"checked\")) {\n    return false;\n  }\n  if (!isVisible(el)) {\n    return false;\n  }\n  if ((tag === \"audio\" || tag === \"video\") && el.hasAttribute(\"controls\")) {\n    return true;\n  }\n  if (el.hasAttribute(\"tabindex\")) {\n    return true;\n  }\n  if (el.hasAttribute(\"contenteditable\") && el.getAttribute(\"contenteditable\") !== \"false\") {\n    return true;\n  }\n  const isNativelyTabbable = [\n    \"button\",\n    \"input\",\n    \"select\",\n    \"textarea\",\n    \"a\",\n    \"audio\",\n    \"video\",\n    \"summary\",\n    \"iframe\"\n  ].includes(tag);\n  if (isNativelyTabbable) {\n    return true;\n  }\n  return isOverflowingAndTabbable(el);\n}\nfunction getTabbableBoundary(root) {\n  var _a, _b;\n  const tabbableElements = getTabbableElements(root);\n  const start = (_a = tabbableElements[0]) != null ? _a : null;\n  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;\n  return { start, end };\n}\nfunction getSlottedChildrenOutsideRootElement(slotElement, root) {\n  var _a;\n  return ((_a = slotElement.getRootNode({ composed: true })) == null ? void 0 : _a.host) !== root;\n}\nfunction getTabbableElements(root) {\n  const walkedEls = /* @__PURE__ */ new WeakMap();\n  const tabbableElements = [];\n  function walk(el) {\n    if (el instanceof Element) {\n      if (el.hasAttribute(\"inert\") || el.closest(\"[inert]\")) {\n        return;\n      }\n      if (walkedEls.has(el)) {\n        return;\n      }\n      walkedEls.set(el, true);\n      if (!tabbableElements.includes(el) && isTabbable(el)) {\n        tabbableElements.push(el);\n      }\n      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {\n        el.assignedElements({ flatten: true }).forEach((assignedEl) => {\n          walk(assignedEl);\n        });\n      }\n      if (el.shadowRoot !== null && el.shadowRoot.mode === \"open\") {\n        walk(el.shadowRoot);\n      }\n    }\n    for (const e of el.children) {\n      walk(e);\n    }\n  }\n  walk(root);\n  return tabbableElements.sort((a, b) => {\n    const aTabindex = Number(a.getAttribute(\"tabindex\")) || 0;\n    const bTabindex = Number(b.getAttribute(\"tabindex\")) || 0;\n    return bTabindex - aTabindex;\n  });\n}\n\nexport {\n  getTabbableBoundary,\n  getTabbableElements\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}