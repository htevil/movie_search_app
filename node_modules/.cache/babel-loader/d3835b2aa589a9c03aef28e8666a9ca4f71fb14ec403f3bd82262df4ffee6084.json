{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst e = (e, t, c) => (c.configurable = !0, c.enumerable = !0, Reflect.decorate && \"object\" != typeof t && Object.defineProperty(e, t, c), c);\nexport { e as desc };","map":{"version":3,"names":["e","desc","t","c","configurable","enumerable","Reflect","decorate","Object","defineProperty"],"sources":["C:\\Users\\ASUS\\Project\\Web Project\\Greekforgreek_project\\React project\\movie_search_app\\node_modules\\@lit\\reactive-element\\src\\decorators\\base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Generates a public interface type that removes private and protected fields.\n * This allows accepting otherwise incompatible versions of the type (e.g. from\n * multiple copies of the same package in `node_modules`).\n */\nexport type Interface<T> = {\n  [K in keyof T]: T[K];\n};\n\nexport type Constructor<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): T;\n};\n\n/**\n * Wraps up a few best practices when returning a property descriptor from a\n * decorator.\n *\n * Marks the defined property as configurable, and enumerable, and handles\n * the case where we have a busted Reflect.decorate zombiefill (e.g. in Angular\n * apps).\n *\n * @internal\n */\nexport const desc = (\n  obj: object,\n  name: PropertyKey | ClassAccessorDecoratorContext<unknown, unknown>,\n  descriptor: PropertyDescriptor\n) => {\n  // For backwards compatibility, we keep them configurable and enumerable.\n  descriptor.configurable = true;\n  descriptor.enumerable = true;\n  if (\n    // We check for Reflect.decorate each time, in case the zombiefill\n    // is applied via lazy loading some Angular code.\n    (Reflect as typeof Reflect & {decorate?: unknown}).decorate &&\n    typeof name !== 'object'\n  ) {\n    // If we're called as a legacy decorator, and Reflect.decorate is present\n    // then we have no guarantees that the returned descriptor will be\n    // defined on the class, so we must apply it directly ourselves.\n\n    Object.defineProperty(obj, name, descriptor);\n  }\n  return descriptor;\n};\n"],"mappings":";;;;;AA8Ba,MAAAA,CAAA,GAAOC,CAClBD,CAAA,EACAE,CAAA,EACAC,CAAA,MAGAA,CAAA,CAAWC,YAAA,IAAe,GAC1BD,CAAA,CAAWE,UAAA,IAAa,GAIrBC,OAAA,CAAkDC,QAAA,IACnC,mBAATL,CAAA,IAMPM,MAAA,CAAOC,cAAA,CAAeT,CAAA,EAAKE,CAAA,EAAMC,CAAA,GAE5BA,CAAA;AAAA,SAAAH,CAAA,IAAAC,IAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}