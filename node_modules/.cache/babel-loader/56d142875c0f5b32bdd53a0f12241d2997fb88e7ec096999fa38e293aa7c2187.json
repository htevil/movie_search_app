{"ast":null,"code":"import { noChange as R, nothing as D } from \"../lit-html.js\";\nimport { directive as e, Directive as i, PartType as t } from \"../directive.js\";\nimport { isSingleExpression as rt, setCommittedValue as dt } from \"../directive-helpers.js\";\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst Ft = e(class extends i {\n  constructor(r) {\n    if (super(r), r.type !== t.PROPERTY && r.type !== t.ATTRIBUTE && r.type !== t.BOOLEAN_ATTRIBUTE) throw Error(\"The `live` directive is not allowed on child or event bindings\");\n    if (!rt(r)) throw Error(\"`live` bindings can only contain a single expression\");\n  }\n  render(r) {\n    return r;\n  }\n  update(r, _ref) {\n    let [e] = _ref;\n    if (e === R || e === D) return e;\n    const i = r.element,\n      n = r.name;\n    if (r.type === t.PROPERTY) {\n      if (e === i[n]) return R;\n    } else if (r.type === t.BOOLEAN_ATTRIBUTE) {\n      if (!!e === i.hasAttribute(n)) return R;\n    } else if (r.type === t.ATTRIBUTE && i.getAttribute(n) === e + \"\") return R;\n    return dt(r), e;\n  }\n});\nexport { Ft as live };","map":{"version":3,"names":["Ft","e","i","constructor","r","type","t","PROPERTY","ATTRIBUTE","BOOLEAN_ATTRIBUTE","Error","rt","render","update","_ref","R","D","element","n","name","hasAttribute","getAttribute","dt","live"],"sources":["C:\\Users\\ASUS\\Project\\Web Project\\Greekforgreek_project\\React project\\movie_search_app\\node_modules\\lit-html\\src\\directives\\live.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange, nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\nimport {isSingleExpression, setCommittedValue} from '../directive-helpers.js';\n\nclass LiveDirective extends Directive {\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      !(\n        partInfo.type === PartType.PROPERTY ||\n        partInfo.type === PartType.ATTRIBUTE ||\n        partInfo.type === PartType.BOOLEAN_ATTRIBUTE\n      )\n    ) {\n      throw new Error(\n        'The `live` directive is not allowed on child or event bindings',\n      );\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n  }\n\n  render(value: unknown) {\n    return value;\n  }\n\n  override update(part: AttributePart, [value]: DirectiveParameters<this>) {\n    if (value === noChange || value === nothing) {\n      return value;\n    }\n    const element = part.element;\n    const name = part.name;\n\n    if (part.type === PartType.PROPERTY) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (value === (element as any)[name]) {\n        return noChange;\n      }\n    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n      if (!!value === element.hasAttribute(name)) {\n        return noChange;\n      }\n    } else if (part.type === PartType.ATTRIBUTE) {\n      if (element.getAttribute(name) === String(value)) {\n        return noChange;\n      }\n    }\n    // Resets the part's value, causing its dirty-check to fail so that it\n    // always sets the value.\n    setCommittedValue(part);\n    return value;\n  }\n}\n\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {LiveDirective};\n"],"mappings":";;;;;;;;MA2FaA,EAAA,GAAOC,CAAA,CA3EpB,cAA4BC,CAAA;EAC1BC,YAAYC,CAAA;IAEV,IADA,MAAMA,CAAA,GAGFA,CAAA,CAASC,IAAA,KAASC,CAAA,CAASC,QAAA,IAC3BH,CAAA,CAASC,IAAA,KAASC,CAAA,CAASE,SAAA,IAC3BJ,CAAA,CAASC,IAAA,KAASC,CAAA,CAASG,iBAAA,EAG7B,MAAUC,KAAA,CACR;IAGJ,KAAKC,EAAA,CAAmBP,CAAA,GACtB,MAAUM,KAAA,CAAM,uDAEnB;EAAA;EAEDE,OAAOR,CAAA;IACL,OAAOA,CACR;EAAA;EAEQS,OAAOT,CAAA,EAAAU,IAAA,EAAsB;IAAA,IAAtB,CAAsBb,CAAA,IAAAa,IAAA;IACpC,IAAIb,CAAA,KAAUc,CAAA,IAAYd,CAAA,KAAUe,CAAA,EAClC,OAAOf,CAAA;IAET,MAAMC,CAAA,GAAUE,CAAA,CAAKa,OAAA;MACfC,CAAA,GAAOd,CAAA,CAAKe,IAAA;IAElB,IAAIf,CAAA,CAAKC,IAAA,KAASC,CAAA,CAASC,QAAA;MAEzB,IAAIN,CAAA,KAAWC,CAAA,CAAgBgB,CAAA,GAC7B,OAAOH,CAAA;IAAA,OAEJ,IAAIX,CAAA,CAAKC,IAAA,KAASC,CAAA,CAASG,iBAAA;MAChC,MAAMR,CAAA,KAAUC,CAAA,CAAQkB,YAAA,CAAaF,CAAA,GACnC,OAAOH,CAAA;IAAA,OAEJ,IAAIX,CAAA,CAAKC,IAAA,KAASC,CAAA,CAASE,SAAA,IAC5BN,CAAA,CAAQmB,YAAA,CAAaH,CAAA,MAAiBjB,CAAA,GAAP,IACjC,OAAOc,CAAA;IAMX,OADAO,EAAA,CAAkBlB,CAAA,GACXH,CACR;EAAA;AAAA;AAAA,SAAAD,EAAA,IAAAuB,IAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}