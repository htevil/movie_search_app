{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forkFocus = exports.forkBlur = void 0;\nexports.handleBlurVisible = handleBlurVisible;\nexports.initFocusVisible = initFocusVisible;\nexports.isFocusVisible = isFocusVisible;\nexports.teardown = teardown;\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n// based on:\n// - https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/utils/focusVisible.js\n// - https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\n\nlet initialized = false;\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\n// @ts-ignore\nlet hadFocusVisibleRecentlyTimeout = null;\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @return {boolean}\n */\n// @ts-ignore\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n\n  // @ts-ignore\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n  if (node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n// @ts-ignore\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\n\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (document.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\n// @ts-ignore\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\n// @ts-ignore\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\n// @ts-ignore\nfunction isFocusVisible(event) {\n  try {\n    return event.target.matches(':focus-visible');\n  } catch (error) {\n    // browsers not implementing :focus-visible will throw a SyntaxError\n    // we use our own heuristic for those browsers\n    // rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  }\n\n  // no need for validFocusTarget check. the user does that by attaching it to\n  // focusable events only\n  return hadKeyboardEvent || focusTriggersKeyboardModality(event.target);\n}\n\n/**\n * Should be called if a blur event is fired on a focus-visible element\n */\nfunction handleBlurVisible() {\n  // To detect a tab/window switch, we look for a blur event followed\n  // rapidly by a visibility change.\n  // If we don't see a visibility change within 100ms, it's probably a\n  // regular focus change.\n  hadFocusVisibleRecently = true;\n  if (typeof document !== 'undefined') {\n    // @ts-ignore\n    window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n    // @ts-ignore\n    hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {\n      hadFocusVisibleRecently = false;\n    }, 100);\n  }\n}\n\n// @ts-ignore\nfunction initFocusVisible(node) {\n  if (!initialized && node != null) {\n    initialized = true;\n    prepare(node.ownerDocument);\n  }\n}\nconst forkFocus =\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(rootProps, handler) => e => {\n  if (typeof rootProps.onFocus === 'function') {\n    rootProps.onFocus(e);\n  }\n  handler(e);\n};\nexports.forkFocus = forkFocus;\nconst forkBlur =\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(rootProps, handler) => e => {\n  if (typeof rootProps.onBlur === 'function') {\n    rootProps.onBlur(e);\n  }\n  handler(e);\n};\nexports.forkBlur = forkBlur;","map":{"version":3,"names":["Object","defineProperty","exports","value","forkFocus","forkBlur","handleBlurVisible","initFocusVisible","isFocusVisible","teardown","initialized","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","focusTriggersKeyboardModality","node","type","tagName","readOnly","isContentEditable","handleKeyDown","event","metaKey","altKey","ctrlKey","handlePointerDown","handleVisibilityChange","document","visibilityState","prepare","doc","addEventListener","removeEventListener","target","matches","error","window","clearTimeout","setTimeout","ownerDocument","rootProps","handler","e","onFocus","onBlur"],"sources":["C:/Users/ASUS/Project/Web Project/Greekforgreek_project/React project/movie_search_app/node_modules/baseui/utils/focusVisible.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forkFocus = exports.forkBlur = void 0;\nexports.handleBlurVisible = handleBlurVisible;\nexports.initFocusVisible = initFocusVisible;\nexports.isFocusVisible = isFocusVisible;\nexports.teardown = teardown;\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n// based on:\n// - https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/utils/focusVisible.js\n// - https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\n\nlet initialized = false;\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\n// @ts-ignore\nlet hadFocusVisibleRecentlyTimeout = null;\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @return {boolean}\n */\n// @ts-ignore\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n\n  // @ts-ignore\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n  if (node.isContentEditable) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n// @ts-ignore\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n  hadKeyboardEvent = true;\n}\n\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\nfunction handleVisibilityChange() {\n  if (document.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\n// @ts-ignore\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\n// @ts-ignore\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\n// @ts-ignore\nfunction isFocusVisible(event) {\n  try {\n    return event.target.matches(':focus-visible');\n  } catch (error) {\n    // browsers not implementing :focus-visible will throw a SyntaxError\n    // we use our own heuristic for those browsers\n    // rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  }\n\n  // no need for validFocusTarget check. the user does that by attaching it to\n  // focusable events only\n  return hadKeyboardEvent || focusTriggersKeyboardModality(event.target);\n}\n\n/**\n * Should be called if a blur event is fired on a focus-visible element\n */\nfunction handleBlurVisible() {\n  // To detect a tab/window switch, we look for a blur event followed\n  // rapidly by a visibility change.\n  // If we don't see a visibility change within 100ms, it's probably a\n  // regular focus change.\n  hadFocusVisibleRecently = true;\n  if (typeof document !== 'undefined') {\n    // @ts-ignore\n    window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n    // @ts-ignore\n    hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {\n      hadFocusVisibleRecently = false;\n    }, 100);\n  }\n}\n\n// @ts-ignore\nfunction initFocusVisible(node) {\n  if (!initialized && node != null) {\n    initialized = true;\n    prepare(node.ownerDocument);\n  }\n}\nconst forkFocus =\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(rootProps, handler) => e => {\n  if (typeof rootProps.onFocus === 'function') {\n    rootProps.onFocus(e);\n  }\n  handler(e);\n};\nexports.forkFocus = forkFocus;\nconst forkBlur =\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(rootProps, handler) => e => {\n  if (typeof rootProps.onBlur === 'function') {\n    rootProps.onBlur(e);\n  }\n  handler(e);\n};\nexports.forkBlur = forkBlur;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}